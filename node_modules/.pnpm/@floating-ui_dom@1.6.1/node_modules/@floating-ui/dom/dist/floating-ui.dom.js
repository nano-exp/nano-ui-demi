import { arrow as tt, computePosition as et } from "../../../../../@floating-ui_core@1.6.0/node_modules/@floating-ui/core/dist/floating-ui.core.js";
import { offset as Ot } from "../../../../../@floating-ui_core@1.6.0/node_modules/@floating-ui/core/dist/floating-ui.core.js";
import { createCoords as x, rectToClientRect as q, round as A, floor as B, max as O, min as D } from "../../../../../@floating-ui_utils@0.2.1/node_modules/@floating-ui/utils/dist/floating-ui.utils.js";
import { getOverflowAncestors as H, isElement as v, getWindow as T, getComputedStyle as w, getDocumentElement as L, isHTMLElement as b, isWebKit as U, getNodeName as W, isOverflowElement as z, getNodeScroll as I, isTableElement as ot, isContainingBlock as X, getContainingBlock as K, getParentNode as V, isLastTraversableNode as Y } from "../../../../../@floating-ui_utils@0.2.1/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.js";
function j(t) {
  const e = w(t);
  let n = parseFloat(e.width) || 0, o = parseFloat(e.height) || 0;
  const i = b(t), r = i ? t.offsetWidth : n, s = i ? t.offsetHeight : o, c = A(n) !== r || A(o) !== s;
  return c && (n = r, o = s), {
    width: n,
    height: o,
    $: c
  };
}
function S(t) {
  return v(t) ? t : t.contextElement;
}
function F(t) {
  const e = S(t);
  if (!b(e))
    return x(1);
  const n = e.getBoundingClientRect(), {
    width: o,
    height: i,
    $: r
  } = j(e);
  let s = (r ? A(n.width) : n.width) / o, c = (r ? A(n.height) : n.height) / i;
  return (!s || !Number.isFinite(s)) && (s = 1), (!c || !Number.isFinite(c)) && (c = 1), {
    x: s,
    y: c
  };
}
const nt = /* @__PURE__ */ x(0);
function G(t) {
  const e = T(t);
  return !U() || !e.visualViewport ? nt : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function it(t, e, n) {
  return e === void 0 && (e = !1), !n || e && n !== T(t) ? !1 : e;
}
function E(t, e, n, o) {
  e === void 0 && (e = !1), n === void 0 && (n = !1);
  const i = t.getBoundingClientRect(), r = S(t);
  let s = x(1);
  e && (o ? v(o) && (s = F(o)) : s = F(t));
  const c = it(r, n, o) ? G(r) : x(0);
  let l = (i.left + c.x) / s.x, f = (i.top + c.y) / s.y, a = i.width / s.x, u = i.height / s.y;
  if (r) {
    const m = T(r), p = o && v(o) ? T(o) : o;
    let g = m.frameElement;
    for (; g && o && p !== m; ) {
      const h = F(g), R = g.getBoundingClientRect(), d = w(g), y = R.left + (g.clientLeft + parseFloat(d.paddingLeft)) * h.x, C = R.top + (g.clientTop + parseFloat(d.paddingTop)) * h.y;
      l *= h.x, f *= h.y, a *= h.x, u *= h.y, l += y, f += C, g = T(g).frameElement;
    }
  }
  return q({
    width: a,
    height: u,
    x: l,
    y: f
  });
}
const st = [":popover-open", ":modal"];
function J(t) {
  let e = !1, n = 0, o = 0;
  function i(r) {
    try {
      e = e || t.matches(r);
    } catch {
    }
  }
  if (st.forEach((r) => {
    i(r);
  }), e) {
    const r = K(t);
    if (r) {
      const s = r.getBoundingClientRect();
      n = s.x, o = s.y;
    }
  }
  return [e, n, o];
}
function rt(t) {
  let {
    elements: e,
    rect: n,
    offsetParent: o,
    strategy: i
  } = t;
  const r = L(o), [s] = e ? J(e.floating) : [!1];
  if (o === r || s)
    return n;
  let c = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = x(1);
  const f = x(0), a = b(o);
  if ((a || !a && i !== "fixed") && ((W(o) !== "body" || z(r)) && (c = I(o)), b(o))) {
    const u = E(o);
    l = F(o), f.x = u.x + o.clientLeft, f.y = u.y + o.clientTop;
  }
  return {
    width: n.width * l.x,
    height: n.height * l.y,
    x: n.x * l.x - c.scrollLeft * l.x + f.x,
    y: n.y * l.y - c.scrollTop * l.y + f.y
  };
}
function ct(t) {
  return Array.from(t.getClientRects());
}
function Q(t) {
  return E(L(t)).left + I(t).scrollLeft;
}
function lt(t) {
  const e = L(t), n = I(t), o = t.ownerDocument.body, i = O(e.scrollWidth, e.clientWidth, o.scrollWidth, o.clientWidth), r = O(e.scrollHeight, e.clientHeight, o.scrollHeight, o.clientHeight);
  let s = -n.scrollLeft + Q(t);
  const c = -n.scrollTop;
  return w(o).direction === "rtl" && (s += O(e.clientWidth, o.clientWidth) - i), {
    width: i,
    height: r,
    x: s,
    y: c
  };
}
function ft(t, e) {
  const n = T(t), o = L(t), i = n.visualViewport;
  let r = o.clientWidth, s = o.clientHeight, c = 0, l = 0;
  if (i) {
    r = i.width, s = i.height;
    const f = U();
    (!f || f && e === "fixed") && (c = i.offsetLeft, l = i.offsetTop);
  }
  return {
    width: r,
    height: s,
    x: c,
    y: l
  };
}
function ut(t, e) {
  const n = E(t, !0, e === "fixed"), o = n.top + t.clientTop, i = n.left + t.clientLeft, r = b(t) ? F(t) : x(1), s = t.clientWidth * r.x, c = t.clientHeight * r.y, l = i * r.x, f = o * r.y;
  return {
    width: s,
    height: c,
    x: l,
    y: f
  };
}
function $(t, e, n) {
  let o;
  if (e === "viewport")
    o = ft(t, n);
  else if (e === "document")
    o = lt(L(t));
  else if (v(e))
    o = ut(e, n);
  else {
    const i = G(t);
    o = {
      ...e,
      x: e.x - i.x,
      y: e.y - i.y
    };
  }
  return q(o);
}
function Z(t, e) {
  const n = V(t);
  return n === e || !v(n) || Y(n) ? !1 : w(n).position === "fixed" || Z(n, e);
}
function at(t, e) {
  const n = e.get(t);
  if (n)
    return n;
  let o = H(t, [], !1).filter((c) => v(c) && W(c) !== "body"), i = null;
  const r = w(t).position === "fixed";
  let s = r ? V(t) : t;
  for (; v(s) && !Y(s); ) {
    const c = w(s), l = X(s);
    !l && c.position === "fixed" && (i = null), (r ? !l && !i : !l && c.position === "static" && !!i && ["absolute", "fixed"].includes(i.position) || z(s) && !l && Z(t, s)) ? o = o.filter((a) => a !== s) : i = c, s = V(s);
  }
  return e.set(t, o), o;
}
function ht(t) {
  let {
    element: e,
    boundary: n,
    rootBoundary: o,
    strategy: i
  } = t;
  const s = [...n === "clippingAncestors" ? at(e, this._c) : [].concat(n), o], c = s[0], l = s.reduce((f, a) => {
    const u = $(e, a, i);
    return f.top = O(u.top, f.top), f.right = D(u.right, f.right), f.bottom = D(u.bottom, f.bottom), f.left = O(u.left, f.left), f;
  }, $(e, c, i));
  return {
    width: l.right - l.left,
    height: l.bottom - l.top,
    x: l.left,
    y: l.top
  };
}
function dt(t) {
  const {
    width: e,
    height: n
  } = j(t);
  return {
    width: e,
    height: n
  };
}
function gt(t, e, n, o) {
  const i = b(e), r = L(e), s = n === "fixed", c = E(t, !0, s, e);
  let l = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const f = x(0);
  if (i || !i && !s)
    if ((W(e) !== "body" || z(r)) && (l = I(e)), i) {
      const h = E(e, !0, s, e);
      f.x = h.x + e.clientLeft, f.y = h.y + e.clientTop;
    } else
      r && (f.x = Q(r));
  let a = c.left + l.scrollLeft - f.x, u = c.top + l.scrollTop - f.y;
  const [m, p, g] = J(o);
  return m && (a += p, u += g, i && (a += e.clientLeft, u += e.clientTop)), {
    x: a,
    y: u,
    width: c.width,
    height: c.height
  };
}
function k(t, e) {
  return !b(t) || w(t).position === "fixed" ? null : e ? e(t) : t.offsetParent;
}
function P(t, e) {
  const n = T(t);
  if (!b(t))
    return n;
  let o = k(t, e);
  for (; o && ot(o) && w(o).position === "static"; )
    o = k(o, e);
  return o && (W(o) === "html" || W(o) === "body" && w(o).position === "static" && !X(o)) ? n : o || K(t) || n;
}
const pt = async function(t) {
  const e = this.getOffsetParent || P, n = this.getDimensions;
  return {
    reference: gt(t.reference, await e(t.floating), t.strategy, t.floating),
    floating: {
      x: 0,
      y: 0,
      ...await n(t.floating)
    }
  };
};
function mt(t) {
  return w(t).direction === "rtl";
}
const yt = {
  convertOffsetParentRelativeRectToViewportRelativeRect: rt,
  getDocumentElement: L,
  getClippingRect: ht,
  getOffsetParent: P,
  getElementRects: pt,
  getClientRects: ct,
  getDimensions: dt,
  getScale: F,
  isElement: v,
  isRTL: mt
};
function wt(t, e) {
  let n = null, o;
  const i = L(t);
  function r() {
    var c;
    clearTimeout(o), (c = n) == null || c.disconnect(), n = null;
  }
  function s(c, l) {
    c === void 0 && (c = !1), l === void 0 && (l = 1), r();
    const {
      left: f,
      top: a,
      width: u,
      height: m
    } = t.getBoundingClientRect();
    if (c || e(), !u || !m)
      return;
    const p = B(a), g = B(i.clientWidth - (f + u)), h = B(i.clientHeight - (a + m)), R = B(f), y = {
      rootMargin: -p + "px " + -g + "px " + -h + "px " + -R + "px",
      threshold: O(0, D(1, l)) || 1
    };
    let C = !0;
    function M(_) {
      const N = _[0].intersectionRatio;
      if (N !== l) {
        if (!C)
          return s();
        N ? s(!1, N) : o = setTimeout(() => {
          s(!1, 1e-7);
        }, 100);
      }
      C = !1;
    }
    try {
      n = new IntersectionObserver(M, {
        ...y,
        // Handle <iframe>s
        root: i.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(M, y);
    }
    n.observe(t);
  }
  return s(!0), r;
}
function Lt(t, e, n, o) {
  o === void 0 && (o = {});
  const {
    ancestorScroll: i = !0,
    ancestorResize: r = !0,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: c = typeof IntersectionObserver == "function",
    animationFrame: l = !1
  } = o, f = S(t), a = i || r ? [...f ? H(f) : [], ...H(e)] : [];
  a.forEach((d) => {
    i && d.addEventListener("scroll", n, {
      passive: !0
    }), r && d.addEventListener("resize", n);
  });
  const u = f && c ? wt(f, n) : null;
  let m = -1, p = null;
  s && (p = new ResizeObserver((d) => {
    let [y] = d;
    y && y.target === f && p && (p.unobserve(e), cancelAnimationFrame(m), m = requestAnimationFrame(() => {
      var C;
      (C = p) == null || C.observe(e);
    })), n();
  }), f && !l && p.observe(f), p.observe(e));
  let g, h = l ? E(t) : null;
  l && R();
  function R() {
    const d = E(t);
    h && (d.x !== h.x || d.y !== h.y || d.width !== h.width || d.height !== h.height) && n(), h = d, g = requestAnimationFrame(R);
  }
  return n(), () => {
    var d;
    a.forEach((y) => {
      i && y.removeEventListener("scroll", n), r && y.removeEventListener("resize", n);
    }), u == null || u(), (d = p) == null || d.disconnect(), p = null, l && cancelAnimationFrame(g);
  };
}
const Rt = tt, Ct = (t, e, n) => {
  const o = /* @__PURE__ */ new Map(), i = {
    platform: yt,
    ...n
  }, r = {
    ...i.platform,
    _c: o
  };
  return et(t, e, {
    ...i,
    platform: r
  });
};
export {
  Rt as arrow,
  Lt as autoUpdate,
  Ct as computePosition,
  H as getOverflowAncestors,
  Ot as offset,
  yt as platform
};
