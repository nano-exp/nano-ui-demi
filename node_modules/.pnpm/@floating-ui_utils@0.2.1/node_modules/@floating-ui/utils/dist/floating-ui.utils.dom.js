function l(n) {
  return a(n) ? (n.nodeName || "").toLowerCase() : "#document";
}
function i(n) {
  var t;
  return (n == null || (t = n.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function y(n) {
  var t;
  return (t = (a(n) ? n.ownerDocument : n.document) || window.document) == null ? void 0 : t.documentElement;
}
function a(n) {
  return n instanceof Node || n instanceof i(n).Node;
}
function S(n) {
  return n instanceof Element || n instanceof i(n).Element;
}
function d(n) {
  return n instanceof HTMLElement || n instanceof i(n).HTMLElement;
}
function s(n) {
  return typeof ShadowRoot > "u" ? !1 : n instanceof ShadowRoot || n instanceof i(n).ShadowRoot;
}
function m(n) {
  const {
    overflow: t,
    overflowX: e,
    overflowY: o,
    display: r
  } = p(n);
  return /auto|scroll|overlay|hidden|clip/.test(t + o + e) && !["inline", "contents"].includes(r);
}
function E(n) {
  return ["table", "td", "th"].includes(l(n));
}
function N(n) {
  const t = h(), e = p(n);
  return e.transform !== "none" || e.perspective !== "none" || (e.containerType ? e.containerType !== "normal" : !1) || !t && (e.backdropFilter ? e.backdropFilter !== "none" : !1) || !t && (e.filter ? e.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((o) => (e.willChange || "").includes(o)) || ["paint", "layout", "strict", "content"].some((o) => (e.contain || "").includes(o));
}
function T(n) {
  let t = u(n);
  for (; d(t) && !w(t); ) {
    if (N(t))
      return t;
    t = u(t);
  }
  return null;
}
function h() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function w(n) {
  return ["html", "body", "#document"].includes(l(n));
}
function p(n) {
  return i(n).getComputedStyle(n);
}
function C(n) {
  return S(n) ? {
    scrollLeft: n.scrollLeft,
    scrollTop: n.scrollTop
  } : {
    scrollLeft: n.pageXOffset,
    scrollTop: n.pageYOffset
  };
}
function u(n) {
  if (l(n) === "html")
    return n;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    n.assignedSlot || // DOM Element detected.
    n.parentNode || // ShadowRoot detected.
    s(n) && n.host || // Fallback.
    y(n)
  );
  return s(t) ? t.host : t;
}
function g(n) {
  const t = u(n);
  return w(t) ? n.ownerDocument ? n.ownerDocument.body : n.body : d(t) && m(t) ? t : g(t);
}
function f(n, t, e) {
  var o;
  t === void 0 && (t = []), e === void 0 && (e = !0);
  const r = g(n), b = r === ((o = n.ownerDocument) == null ? void 0 : o.body), c = i(r);
  return b ? t.concat(c, c.visualViewport || [], m(r) ? r : [], c.frameElement && e ? f(c.frameElement) : []) : t.concat(r, f(r, [], e));
}
export {
  p as getComputedStyle,
  T as getContainingBlock,
  y as getDocumentElement,
  g as getNearestOverflowAncestor,
  l as getNodeName,
  C as getNodeScroll,
  f as getOverflowAncestors,
  u as getParentNode,
  i as getWindow,
  N as isContainingBlock,
  S as isElement,
  d as isHTMLElement,
  w as isLastTraversableNode,
  a as isNode,
  m as isOverflowElement,
  s as isShadowRoot,
  E as isTableElement,
  h as isWebKit
};
