import { evaluate as Y, getPaddingObject as F, getAlignmentAxis as $, getAlignment as L, getSide as X, getSideAxis as _, getAxisLength as z, min as M, clamp as H } from "../../../../../@floating-ui_utils@0.2.1/node_modules/@floating-ui/utils/dist/floating-ui.utils.js";
import { rectToClientRect as Q } from "../../../../../@floating-ui_utils@0.2.1/node_modules/@floating-ui/utils/dist/floating-ui.utils.js";
function S(o, s, f) {
  let {
    reference: e,
    floating: i
  } = o;
  const l = _(s), n = $(s), d = z(n), g = X(s), r = l === "y", x = e.x + e.width / 2 - i.width / 2, a = e.y + e.height / 2 - i.height / 2, m = e[d] / 2 - i[d] / 2;
  let t;
  switch (g) {
    case "top":
      t = {
        x,
        y: e.y - i.height
      };
      break;
    case "bottom":
      t = {
        x,
        y: e.y + e.height
      };
      break;
    case "right":
      t = {
        x: e.x + e.width,
        y: a
      };
      break;
    case "left":
      t = {
        x: e.x - i.width,
        y: a
      };
      break;
    default:
      t = {
        x: e.x,
        y: e.y
      };
  }
  switch (L(s)) {
    case "start":
      t[n] -= m * (f && r ? -1 : 1);
      break;
    case "end":
      t[n] += m * (f && r ? -1 : 1);
      break;
  }
  return t;
}
const G = async (o, s, f) => {
  const {
    placement: e = "bottom",
    strategy: i = "absolute",
    middleware: l = [],
    platform: n
  } = f, d = l.filter(Boolean), g = await (n.isRTL == null ? void 0 : n.isRTL(s));
  let r = await n.getElementRects({
    reference: o,
    floating: s,
    strategy: i
  }), {
    x,
    y: a
  } = S(r, e, g), m = e, t = {}, c = 0;
  for (let u = 0; u < d.length; u++) {
    const {
      name: h,
      fn: v
    } = d[u], {
      x: b,
      y: p,
      data: D,
      reset: w
    } = await v({
      x,
      y: a,
      initialPlacement: e,
      placement: m,
      strategy: i,
      middlewareData: t,
      rects: r,
      platform: n,
      elements: {
        reference: o,
        floating: s
      }
    });
    x = b ?? x, a = p ?? a, t = {
      ...t,
      [h]: {
        ...t[h],
        ...D
      }
    }, w && c <= 50 && (c++, typeof w == "object" && (w.placement && (m = w.placement), w.rects && (r = w.rects === !0 ? await n.getElementRects({
      reference: o,
      floating: s,
      strategy: i
    }) : w.rects), {
      x,
      y: a
    } = S(r, m, g)), u = -1);
  }
  return {
    x,
    y: a,
    placement: m,
    strategy: i,
    middlewareData: t
  };
}, I = (o) => ({
  name: "arrow",
  options: o,
  async fn(s) {
    const {
      x: f,
      y: e,
      placement: i,
      rects: l,
      platform: n,
      elements: d,
      middlewareData: g
    } = s, {
      element: r,
      padding: x = 0
    } = Y(o, s) || {};
    if (r == null)
      return {};
    const a = F(x), m = {
      x: f,
      y: e
    }, t = $(i), c = z(t), u = await n.getDimensions(r), h = t === "y", v = h ? "top" : "left", b = h ? "bottom" : "right", p = h ? "clientHeight" : "clientWidth", D = l.reference[c] + l.reference[t] - m[t] - l.floating[c], w = m[t] - l.reference[t], O = await (n.getOffsetParent == null ? void 0 : n.getOffsetParent(r));
    let A = O ? O[p] : 0;
    (!A || !await (n.isElement == null ? void 0 : n.isElement(O))) && (A = d.floating[p] || l.floating[c]);
    const B = D / 2 - w / 2, C = A / 2 - u[c] / 2 - 1, E = M(a[v], C), V = M(a[b], C), P = E, j = A - u[c] - V, y = A / 2 - u[c] / 2 + B, R = H(P, y, j), T = !g.arrow && L(i) != null && y !== R && l.reference[c] / 2 - (y < P ? E : V) - u[c] / 2 < 0, k = T ? y < P ? y - P : y - j : 0;
    return {
      [t]: m[t] + k,
      data: {
        [t]: R,
        centerOffset: y - R - k,
        ...T && {
          alignmentOffset: k
        }
      },
      reset: T
    };
  }
});
async function W(o, s) {
  const {
    placement: f,
    platform: e,
    elements: i
  } = o, l = await (e.isRTL == null ? void 0 : e.isRTL(i.floating)), n = X(f), d = L(f), g = _(f) === "y", r = ["left", "top"].includes(n) ? -1 : 1, x = l && g ? -1 : 1, a = Y(s, o);
  let {
    mainAxis: m,
    crossAxis: t,
    alignmentAxis: c
  } = typeof a == "number" ? {
    mainAxis: a,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...a
  };
  return d && typeof c == "number" && (t = d === "end" ? c * -1 : c), g ? {
    x: t * x,
    y: m * r
  } : {
    x: m * r,
    y: t * x
  };
}
const J = function(o) {
  return o === void 0 && (o = 0), {
    name: "offset",
    options: o,
    async fn(s) {
      var f, e;
      const {
        x: i,
        y: l,
        placement: n,
        middlewareData: d
      } = s, g = await W(s, o);
      return n === ((f = d.offset) == null ? void 0 : f.placement) && (e = d.arrow) != null && e.alignmentOffset ? {} : {
        x: i + g.x,
        y: l + g.y,
        data: {
          ...g,
          placement: n
        }
      };
    }
  };
};
export {
  I as arrow,
  G as computePosition,
  J as offset,
  Q as rectToClientRect
};
